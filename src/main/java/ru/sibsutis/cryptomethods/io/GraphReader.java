package ru.sibsutis.cryptomethods.io;

import lombok.Getter;
import ru.sibsutis.cryptomethods.core.Edge;

import java.io.*;
import java.util.*;

@Getter
public class GraphReader {

    private int n;
    private int m;
    private List<Edge> edges;
    private int[] colors;

    public GraphReader() {
        this.edges = new ArrayList<>();
    }

    public void readFromFile(String filename) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {

            String firstLine = reader.readLine();
            if (firstLine == null) {
                throw new IOException("File is empty");
            }

            String[] parts = firstLine.trim().split("\\s+");
            if (parts.length < 2) {
                throw new IOException("N and M expected");
            }

            this.n = Integer.parseInt(parts[0]);
            this.m = Integer.parseInt(parts[1]);

            long maxEdges = (long) n * n;
            if (m > maxEdges) {
                throw new IOException(String.format(
                        "Error: m = %d > n? = %d", m, maxEdges));
            }

            this.colors = new int[n];
            Arrays.fill(colors, -1);
            this.edges = new ArrayList<>();

            for (int i = 0; i < m; i++) {
                String line = reader.readLine();
                if (line == null) {
                    throw new IOException(String.format(
                            "Not enough edges. Expected %d", m));
                }

                line = line.trim();
                if (line.isEmpty()) {
                    i--;
                    continue;
                }

                parts = line.split("\\s+");
                if (parts.length < 2) {
                    throw new IOException("Inncorrect edge format. Expected: u v");
                }

                int u = Integer.parseInt(parts[0]);
                int v = Integer.parseInt(parts[1]);

                if (u < 0 || u >= n || v < 0 || v >= n) {
                    throw new IOException(
                            String.format("Incorrect vertices indexes %d or %d. Expected: 0..%d",
                                    u, v, n - 1));
                }

                edges.add(new Edge(u, v));
            }

            int verticesWithColor = 0;
            for (int i = 0; i < n; i++) {
                String line = reader.readLine();
                if (line == null) {
                    throw new IOException(String.format(
                            "Not enough vertices. Expected %d", n));
                }

                line = line.trim();
                if (line.isEmpty()) {
                    i--;
                    continue;
                }

                parts = line.split("\\s+");
                if (parts.length < 2) {
                    throw new IOException("Incorrect vertex color format. Expected: vertex color");
                }

                int vertex = Integer.parseInt(parts[0]);
                String colorStr = parts[1];

                if (vertex < 0 || vertex >= n) {
                    throw new IOException(
                            String.format("Incorrect vertex index %d. Expected: 0..%d",
                                    vertex, n - 1));
                }

                int colorInt = binaryColorToInt(colorStr);
                if (colorInt == -1) {
                    throw new IOException(
                            String.format("Invalid color code: %s. Expected: 00, 01, 10", colorStr));
                }

                colors[vertex] = colorInt;
                verticesWithColor++;
            }

            for (int i = 0; i < n; i++) {
                if (colors[i] == -1) {
                    throw new IOException(String.format("Vertex %d has no color", i));
                }
            }

            System.out.println("Graph loaded:");

        } catch (NumberFormatException e) {
            throw new IOException("Parsing error: " + e.getMessage());
        }
    }

    private int binaryColorToInt(String binaryColor) {
        return switch (binaryColor) {
            case "00" -> 0;
            case "01" -> 1;
            case "10" -> 2;
            default -> -1;
        };
    }

    private static String intToBinaryColor(int color) {
        return switch (color) {
            case 0 -> "00";
            case 1 -> "01";
            case 2 -> "10";
            default -> throw new IllegalArgumentException("Неверный код цвета: " + color);
        };
    }


    public static String generateAndSaveGraph () throws IOException {
        Random rand = new Random();
        String defaultPath = "src/main/resources/autogenerated_graph.txt";

        File file = new File(defaultPath);
        file.getParentFile().mkdirs();

        int n = rand.nextInt(50, 100);
        int m = rand.nextInt(n - 1, Math.min(n * (n - 1) / 2, 50000));

        System.out.printf("Generating graph: n=%d, m=%d\n", n, m);

        int[] colors = new int[n];
        Arrays.fill(colors, -1);

        colors[0] = rand.nextInt(3);

        List<Edge> edges = new ArrayList<>();
        Set<String> usedEdges = new HashSet<>();

        for (int i = 1; i < n; i++) {
            int parent = rand.nextInt(i);
            int parentColor = colors[parent];
            int myColor;
            do {
                myColor = rand.nextInt(3);
            } while (myColor == parentColor);

            colors[i] = myColor;
            edges.add(new Edge(i, parent));
            usedEdges.add(i + "_" + parent);
            usedEdges.add(parent + "_" + i);
        }

        int attemptsWithoutSuccess = 0;
        int maxAttemptsBeforeExit = Math.min(10000, n * n);

        while (edges.size() < m && attemptsWithoutSuccess < maxAttemptsBeforeExit) {
            int u = rand.nextInt(n);
            int v = rand.nextInt(n);

            if (u == v || colors[u] == colors[v] ||
                    usedEdges.contains(u + "_" + v) ||
                    usedEdges.contains(v + "_" + u)) {

                attemptsWithoutSuccess++;
                continue;
            }

            edges.add(new Edge(u, v));
            usedEdges.add(u + "_" + v);
            usedEdges.add(v + "_" + u);
            attemptsWithoutSuccess = 0;

            if (edges.size() % 1000 == 0) {
                System.out.printf("Progress: %d/%d edges\n", edges.size(), m);
            }
        }

        if (attemptsWithoutSuccess >= maxAttemptsBeforeExit) {
            System.out.println("Too many failed attempts. Stopping.");
        }

        m = edges.size();

        try (PrintWriter writer = new PrintWriter(new FileWriter(defaultPath))) {
            writer.println(n + " " + m);

            for (Edge edge : edges) {
                writer.println(edge.getU() + " " + edge.getV());
            }

            for (int i = 0; i < n; i++) {
                writer.println(i + " " + intToBinaryColor(colors[i]));
            }
        }

        System.out.printf("Graph saved to: %s (n=%d, m=%d)\n", defaultPath, n, m);
        return defaultPath;
    }
}